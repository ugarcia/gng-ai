// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.VampireBossEnemyAI = (function(_super) {
    __extends(VampireBossEnemyAI, _super);

    VampireBossEnemyAI.prototype.states = {
      SHOOTING: 2,
      HALT: 5,
      SLEEPING: 9,
      FLOATING: 10,
      SHIELDING: 11,
      FLYING: 12
    };

    VampireBossEnemyAI.prototype.attackCycle = [2, 2, 2, 11, 12, 12];

    VampireBossEnemyAI.prototype.haltStateDuration = 0;

    VampireBossEnemyAI.prototype.haltMaxDuration = 0;

    VampireBossEnemyAI.prototype.wakeupDistance = 200;

    VampireBossEnemyAI.prototype.flyAngle = 0;

    VampireBossEnemyAI.prototype.flyCenter = null;

    VampireBossEnemyAI.prototype.flyRadius = 0;

    VampireBossEnemyAI.prototype.flyOffset = 75;

    VampireBossEnemyAI.prototype.flySpeed = 0.03;

    VampireBossEnemyAI.prototype.flyX = 1;

    function VampireBossEnemyAI(obj, target, level) {
      VampireBossEnemyAI.__super__.constructor.call(this, obj, target, level, 0);
    }

    VampireBossEnemyAI.prototype.init = function() {
      VampireBossEnemyAI.__super__.init.apply(this, arguments);
      this.state = this.states.SLEEPING;
      switch (Math.floor(5 * Math.random())) {
        case 0:
        case 1:
          return this.wakeupDistance = 99999;
        case 2:
        case 3:
          return this.obj.instance_vars[1] = 0;
      }
    };

    VampireBossEnemyAI.prototype.setState = function(state) {
      var alpha, d, dx, dy, m;
      this.state = state;
      this.haltStateDuration = 0;
      switch (this.state) {
        case this.states.SHOOTING:
          this.actionTimeout = 1 * Math.random();
          break;
        case this.states.FLOATING:
          this.actionTimeout = 2 * Math.random();
          break;
        case this.states.SHIELDING:
          this.actionTimeout = 5 * Math.random();
          break;
        case this.states.FLYING:
          this.actionTimeout = 2 + Math.random();
          dx = this.obj.x - this.target.x;
          dy = this.target.y - this.obj.y;
          this.flyX = dx / Math.abs(dx);
          alpha = Math.atan(dy / dx);
          if (!(dx > 0)) {
            alpha += Math.PI;
          }
          d = Math.sqrt(dx * dx + dy * dy);
          m = {
            x: this.target.x + d * Math.cos(alpha) / 2,
            y: this.target.y - d * Math.sin(alpha) / 2
          };
          this.flyCenter = {
            x: m.x - this.flyX * this.flyOffset * Math.sin(alpha),
            y: m.y - this.flyX * this.flyOffset * Math.cos(alpha)
          };
          dx = this.obj.x - this.flyCenter.x;
          dy = this.flyCenter.y - this.obj.y;
          this.flyAngle = Math.atan(dy / dx);
          if (!(dx > 0)) {
            this.flyAngle += Math.PI;
          }
          this.flyRadius = Math.sqrt(dx * dx + dy * dy);
      }
      return VampireBossEnemyAI.__super__.setState.apply(this, arguments);
    };

    VampireBossEnemyAI.prototype.update = function(dt) {
      var hasLOStoTarget, nextY;
      VampireBossEnemyAI.__super__.update.call(this, dt);
      this.haltStateDuration += dt;
      hasLOStoTarget = this.target && this.obj.lineOfSight && (this.obj.lineOfSight.hasLOSto(this.target.x, this.target.bbox.bottom) || this.obj.lineOfSight.hasLOSto(this.target.x, this.target.bbox.top));
      switch (this.state) {
        case this.states.SLEEPING:
          if (hasLOStoTarget && cr.distanceTo(this.obj.x, this.obj.y, this.target.x, this.target.y) < this.wakeupDistance && this.obj.instance_vars[1] <= 0) {
            return this.setState(this.states.HALT);
          }
          break;
        case this.states.HALT:
          if (this.haltStateDuration > this.haltMaxDuration) {
            this.lastAttackState = this.nextAttackState();
            this.setState(this.lastAttackState);
            return this.haltMaxDuration = Math.random() * (EnemyAI.levels.IMPOSSIBLE - Math.min(EnemyAI.levels.IMPOSSIBLE, this.level + 2 * (1 - this.obj.instance_vars[0] / this.maxHealth)));
          }
          break;
        case this.states.FLYING:
          if (this.actionTimeout > 0) {
            this.obj.x = this.flyCenter.x + this.flyRadius * Math.cos(this.flyAngle);
            nextY = this.flyCenter.y - this.flyRadius * Math.sin(this.flyAngle);
            if ((nextY > this.obj.y && nextY - this.target.y > 150) || (nextY < this.obj.y && this.target.y - nextY > 150)) {
              this.setState(this.states.HALT);
            } else {
              this.obj.y = nextY;
            }
            this.flyAngle -= this.flyX * this.flySpeed;
            return this.obj.set_bbox_changed();
          } else {
            return this.setState(this.states.HALT);
          }
          break;
        case this.states.FLOATING:
          if (this.actionTimeout > 0) {

          } else {
            return this.setState(this.states.HALT);
          }
          break;
        case this.states.SHIELDING:
          if (this.actionTimeout > 0) {

          } else {
            return this.setState(this.states.HALT);
          }
          break;
        case this.states.SHOOTING:
          if (this.actionTimeout > 0) {

          } else {
            return this.setState(this.states.HALT);
          }
      }
    };

    return VampireBossEnemyAI;

  })(EnemyAI);

}).call(this);
